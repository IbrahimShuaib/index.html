<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Neon Dodge: Arcade Madness</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    display: grid;
    place-items: center;
    color: #0ff;
    font-family: 'Press Start 2P', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  canvas {
    background: #000;
    border: 4px solid #0ff;
    image-rendering: pixelated;
    box-shadow: 0 0 18px #0ff, 0 0 36px #0ff;
  }
  /* CRT scanlines */
  body::after {
    content: "";
    position: fixed; inset: 0;
    background: repeating-linear-gradient(
      to bottom,
      rgba(255,255,255,0.03),
      rgba(255,255,255,0.03) 1px,
      transparent 1px,
      transparent 3px
    );
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="game" width="420" height="600" aria-label="Neon Dodge"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// State
let player, enemies, powerUps, stars, boss, keys, score, best, running, spawnTimer, powerTimer, slowMo, shield, doublePoints, inited;

// Timing
let t = 0;

// Beep synth (no external files, works offline)
let audioCtx;
function beep(freq=440, type='square', duration=0.08, vol=0.2){
  try {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
    o.stop(audioCtx.currentTime + duration);
  } catch {}
}
const sfx = {
  start: () => { beep(880,'square',0.07,0.25); setTimeout(()=>beep(1320,'square',0.07,0.25),80); },
  crash: () => { beep(220,'sawtooth',0.15,0.3); setTimeout(()=>beep(110,'sawtooth',0.2,0.35),120); },
  power: () => { beep(990,'triangle',0.05,0.25); setTimeout(()=>beep(1320,'triangle',0.05,0.25),60); },
  score: () => { beep(660,'square',0.03,0.15); }
};

// Init
function init(){
  player = { x: W/2-15, y: H-44, w: 30, h: 10, speed: 5 };
  enemies = [];
  powerUps = [];
  stars = Array.from({length: 70}, () => ({ x: Math.random()*W, y: Math.random()*H, s: 0.6 + Math.random()*1.8 }));
  boss = null;
  keys = {};
  score = 0;
  best = Number(localStorage.getItem('neon_best') || 0);
  running = false;
  spawnTimer = 0;
  powerTimer = 0;
  slowMo = false;
  shield = false;
  doublePoints = false;
  inited = true;
}
init();

// Input
document.addEventListener('keydown', e => {
  const k = e.key.toLowerCase();
  keys[k] = true;
  if (!running && (e.key === 'Enter' || e.key === ' ')) startGame();
});
document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

// Start/reset
function startGame(){
  score = 0;
  enemies.length = 0;
  powerUps.length = 0;
  boss = null;
  spawnTimer = 0;
  powerTimer = 0;
  slowMo = shield = doublePoints = false;
  player.x = W/2 - player.w/2;
  running = true;
  sfx.start();
}

// Factories
function makeEnemy(){
  return {
    x: Math.random()*(W-24),
    y: -24,
    w: 18 + Math.random()*26,
    h: 10 + Math.random()*12,
    vy: 2 + Math.random()*3
  };
}
function makePowerUp(){
  const types = ['shield','slow','double'];
  const type = types[Math.floor(Math.random()*types.length)];
  return { x: Math.random()*(W-14), y: -16, w: 14, h: 14, vy: 2.2, type };
}
function makeBoss(){
  return { x: W/2-60, y: -40, w: 120, h: 28, vy: 1.7, hp: 12 };
}

// Core
function collide(a,b){
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

function gameOver(){
  running = false;
  sfx.crash();
  best = Math.max(best, score);
  localStorage.setItem('neon_best', String(best));
}

function activatePower(type){
  sfx.power();
  if (type === 'shield') shield = true;
  if (type === 'slow'){ slowMo = true; powerTimer = 320; }
  if (type === 'double'){ doublePoints = true; powerTimer = 320; }
}

function update(){
  if (!inited) return;
  t++;

  // Stars
  stars.forEach(s => {
    s.y += s.s * (slowMo ? 0.35 : 1);
    if (s.y > H) { s.y = -2; s.x = Math.random()*W; }
  });

  if (!running) return;

  // Player movement
  if (keys['arrowleft'] || keys['a']) player.x -= player.speed;
  if (keys['arrowright'] || keys['d']) player.x += player.speed;
  player.x = Math.max(0, Math.min(W - player.w, player.x));

  // Spawning
  spawnTimer++;
  const spawnEvery = slowMo ? 95 : Math.max(28, 60 - Math.floor(score/120));
  if (spawnTimer >= spawnEvery){
    enemies.push(makeEnemy());
    if (Math.random() < 0.12) powerUps.push(makePowerUp());
    spawnTimer = 0;
  }

  // Boss waves every 500 points (once per threshold)
  if (!boss && score >= 500 && Math.floor((score-10)/500) < Math.floor(score/500)){
    boss = makeBoss();
  }

  // Move enemies
  const speedScale = slowMo ? 0.4 : 1;
  enemies.forEach(e => e.y += e.vy * speedScale);
  // Off-screen -> score
  enemies = enemies.filter(e => {
    if (e.y > H){
      score += doublePoints ? 20 : 10;
      if (score % 50 === 0) sfx.score();
      return false;
    }
    return true;
  });

  // Power-ups
  powerUps.forEach(p => p.y += p.vy * speedScale);
  powerUps = powerUps.filter(p => p.y < H);

  // Boss
  if (boss){
    boss.y += boss.vy * speedScale;
    if (boss.y > H) boss = null;
  }

  // Collisions: enemies
  for (const e of enemies){
    if (collide(player, e)){
      if (shield){ shield = false; e.y = H+1; }
      else { gameOver(); return; }
    }
  }
  // Collisions: power-ups
  for (const p of powerUps){
    if (collide(player, p)){
      activatePower(p.type);
      p.y = H+1;
    }
  }
  // Collisions: boss
  if (boss && collide(player, boss)){
    if (shield){ shield = false; boss.hp--; }
    else { gameOver(); return; }
    if (boss.hp <= 0){ boss = null; score += 120; sfx.score(); }
  }

  // Power-up timers
  if (powerTimer > 0){
    powerTimer--;
    if (powerTimer === 0){ slowMo = false; doublePoints = false; }
  }
}

// Drawing
function drawText(text, size, y, color="#0ff", glow="#0ff"){
  ctx.font = `${size}px 'Press Start 2P'`;
  ctx.fillStyle = color;
  ctx.textAlign = 'center';
  ctx.shadowColor = glow;
  ctx.shadowBlur = 18;
  ctx.fillText(text, W/2, y);
  ctx.shadowBlur = 0;
}

function draw(){
  if (!inited) return;

  // Background
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,W,H);

  // Starfield
  ctx.fillStyle = "rgba(0,255,255,0.9)";
  stars.forEach(s => ctx.fillRect(s.x, s.y, 2, 2));

  // Player
  ctx.fillStyle = shield ? "#ff0" : "#0ff";
  ctx.shadowColor = ctx.fillStyle;
  ctx.shadowBlur = 14;
  ctx.fillRect(player.x, player.y, player.w, player.h);
  ctx.shadowBlur = 0;

  // Enemies
  ctx.fillStyle = "#f0f";
  ctx.shadowColor = "#f0f";
  ctx.shadowBlur = 14;
  enemies.forEach(e => ctx.fillRect(e.x, e.y, e.w, e.h));
  ctx.shadowBlur = 0;

  // Power-ups
  powerUps.forEach(p => {
    ctx.fillStyle = p.type === 'shield' ? "#ff0" : p.type === 'slow' ? "#0f0" : "#09f";
    ctx.fillRect(p.x, p.y, p.w, p.h);
  });

  // Boss
  if (boss){
    ctx.fillStyle = "#f33";
    ctx.shadowColor = "#f33";
    ctx.shadowBlur = 20;
    ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
    ctx.shadowBlur = 0;
    // Boss HP pips
    for (let i=0;i<boss.hp;i++){
      ctx.fillStyle = "#f33";
      ctx.fillRect(10 + i*8, 56, 6, 6);
    }
  }

  // HUD
  drawText(`SCORE: ${score}`, 12, 22, "#0ff");
  drawText(`BEST: ${best}`, 12, 40, "#0ff");

  if (!running){
    // Attract/start screen
    const pulse = 0.5 + 0.5*Math.sin(t/20);
    drawText("NEON DODGE", 22, H/2 - 40, "#ff0", "#ff0");
    ctx.globalAlpha = 0.6 + 0.4*pulse;
    drawText("PRESS ENTER", 12, H/2, "#0ff", "#0ff");
    ctx.globalAlpha = 1;
    drawText("← → or A / D", 10, H/2 + 28, "#09f");
  }

  if (!running && score > 0){
    // Game over banner
    drawText("GAME OVER", 14, H/2 + 60, "#f66", "#f66");
  }
}

// Loop
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
